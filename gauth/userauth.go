/*
DESCRIPTION
  Google authentication ("gauth") services using OAuth2.

AUTHORS
  Alan Noble <alan@ausocean.org>

LICENSE
  Copyright (C) 2024 the Australian Ocean Lab (AusOcean)

  This is free software: you can redistribute it and/or modify it
  under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  It is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  in gpl.txt. If not, see http://www.gnu.org/licenses/.
*/

// Package gauth implements authentication for Google services.
// The LoginHandler, LogoutHandler and CallbackHandler are intended
// to be wrapped by http.HandleFunc handlers.
// For example:
//
//	var auth *gauth.UserAuth
//	...
//	http.HandleFunc("/login", func(w http.ResponseWriter, r *http.Request) { auth.loginHandler(w, r) }
package gauth

import (
	"context"
	"encoding/gob"
	"errors"
	"fmt"
	"log"
	"net/http"
	"net/url"
	"os"
	"sync"

	"github.com/ausocean/cloud/backend"
	"github.com/google/uuid"
	"github.com/gorilla/sessions"
	"golang.org/x/oauth2"
	"golang.org/x/oauth2/google"
	"google.golang.org/api/idtoken"
	"google.golang.org/api/people/v1"
)

const (
	// Keys used for default OAuth session.
	oauthTokenSessionKey = "oauth_token"
	idTokenSessionKey    = "id_token"
	profileKey           = "google_profile"

	// Key used in the OAuth flow session to store the URL to
	// redirect the user to after the OAuth flow is complete.
	oauthFlowRedirectKey = "redirect"

	// Default timeout (1 day).
	oauthMaxAge = 60 * 60 * 24

	// Default OAuth redirect URL.
	oauthRedirectUTL = "http://localhost:8080/oauth2callback"
)

// Profile holds info about the logged-in user.
// GivenName, FamilyName, Email, and Locale come from the Google user profile.
// Data is optional non-persistent data associated with the user.
type Profile struct {
	GivenName  string
	FamilyName string
	Email      string
	Locale     string
	Data       string
}

// UserAuth implements authentication of Google users using OAuth2.
// User authentication involves two steps:
//
//	Redirecting the user to Google's authorization service.
//	Processing the response when Google redirects the user back to us.
//
// See also:
//
//	https://godoc.org/google.golang.org/api/people/v1
//	https://developers.google.com/people/v1/how-tos/authorizing
type UserAuth struct {
	sync.Mutex
	ProjectID string                // GAE project ID.
	ClientID  string                // Oauth2 client ID.
	SessionID string                // Default OAuth2 session ID.
	MaxAge    int                   // OAuth2 max age in seconds.
	cfg       *oauth2.Config        // OAuth2 configuration.
	NetStore  *sessions.CookieStore // Session state (only used for net/http implementations)
}

var (
	NotConfigured   = errors.New("oauth2 not configured")
	SessionNotFound = errors.New("oauth2 session not found")
	TokenNotFound   = errors.New("oauth2 token not found")
	TokenInvalid    = errors.New("oauth2 token invalid")
	ProfileNotFound = errors.New("profile not found")
)

// ErrOauth2RedirectError is used to wrap errors from OAuth2 redirects
// and implements the error interface.
type ErrOauth2RedirectError struct {
	err string
}

func (e *ErrOauth2RedirectError) Error() string {
	return fmt.Sprintf("received error from oauth2 callback: %v", e.err)
}

func (e *ErrOauth2RedirectError) Is(target error) bool {
	_, ok := target.(*ErrOauth2RedirectError)
	return ok
}

// Init initializes Google user authentication using OAuth2.
// It requires the use of two secrets obtained via GetSecrets:
//
//	clientSecret: the OAuth 2 client secret for the given client ID.
//	sessionKey:   the secure cookie generated by securecookie.GenerateRandomKey(32).
func (ua *UserAuth) Init(h backend.Handler) {
	ua.Lock()
	defer ua.Unlock()

	if ua.cfg != nil {
		return // Already initialized!
	}

	// Register gobs for the OAuth2 token and user profile.
	gob.Register(&oauth2.Token{})
	gob.Register(&Profile{})

	// Get our client secrets.
	ctx := context.Background()
	secrets, err := GetSecrets(ctx, ua.ProjectID, []string{"clientSecret", "sessionKey"})
	if err != nil {
		log.Printf("GetSecrets failed with error: %v", err)
		return
	}

	// Session ID is the name the default OAuth2 session.
	if ua.SessionID == "" {
		ua.SessionID = ua.ProjectID + "Auth"
	}
	if ua.MaxAge == 0 {
		ua.MaxAge = oauthMaxAge
	}

	// Configure our OAuth URL.
	ua.cfg = configureOAuthClient(ua.ClientID, secrets["clientSecret"])

	// Only create a CookieStore if using net/http.
	_, isNetHandler := h.(*backend.NetHandler)
	if isNetHandler {
		ua.NetStore = sessions.NewCookieStore([]byte(secrets["sessionKey"]))
	}

	return
}

// configureOAuthClient configures the URL that is sent to
// Google's authorization service, requesting the use of the "email"
// and "profile" OAuth scopes.
func configureOAuthClient(clientID, clientSecret string) *oauth2.Config {
	redirectURL := os.Getenv("OAUTH2_CALLBACK")
	if redirectURL == "" {
		log.Printf("OAUTH2_CALLBACK not defined; defaulting to " + oauthRedirectUTL)
		redirectURL = oauthRedirectUTL
	}
	return &oauth2.Config{
		ClientID:     clientID,
		ClientSecret: clientSecret,
		RedirectURL:  redirectURL,
		Scopes:       []string{"email", "profile"},
		Endpoint:     google.Endpoint,
	}
}

// LoginHandler initiates an OAuth flow to authenticate the user,
// storing the state in a session of age oauthMaxAge. The session ID,
// which is a UUID, is used as the OAuth state parameter.
// See also https://godoc.org/golang.org/x/oauth2#Config.AuthCodeURL.
func (ua *UserAuth) LoginHandler(h backend.Handler) error {
	ua.Lock()
	defer ua.Unlock()

	if ua.cfg == nil {
		return NotConfigured
	}

	sessID := uuid.New().String()
	oauthFlowSession, err := h.LoadSession(sessID)
	if err != nil {
		return fmt.Errorf("could not create session %s: %w", sessID, err)
	}
	err = oauthFlowSession.SetMaxAge(ua.MaxAge)
	if err != nil {
		return fmt.Errorf("unable to set session MaxAge: %w", err)
	}

	redirectURL, err := validateRedirectURL(h.FormValue("redirect"))
	if err != nil {
		return fmt.Errorf("invalid redirect URL: %w", err)
	}
	oauthFlowSession.Set(oauthFlowRedirectKey, redirectURL)

	err = h.SaveSession(oauthFlowSession)
	if err != nil {
		return fmt.Errorf("could not save session %s: %w", sessID, err)
	}

	// NB: Offline access is required to obtain a refresh token.
	url := ua.cfg.AuthCodeURL(sessID, oauth2.AccessTypeOffline)
	return h.Redirect(url, http.StatusFound)
}

// validateRedirectURL checks that the URL provided is valid, i.e.,
// relative to this server. If the URL is missing, redirect the user
// to our home page.
func validateRedirectURL(path string) (string, error) {
	if path == "" {
		return "/", nil
	}

	url, err := url.Parse(path)
	if err != nil {
		return "/", err
	}
	if url.IsAbs() {
		return "/", errors.New("URL must not be absolute")
	}
	return path, nil
}

// CallbackHandler completes the OAuth flow, retrieves the user's
// profile information and stores info in the default session.
func (ua *UserAuth) CallbackHandler(h backend.Handler) (*Profile, error) {
	ua.Lock()
	defer ua.Unlock()

	if ua.cfg == nil {
		return nil, NotConfigured
	}

	redirectErr := h.FormValue("error")
	if redirectErr != "" {
		return nil, &ErrOauth2RedirectError{err: redirectErr}
	}

	oauthFlowSession, err := h.LoadSession(h.FormValue("state"))
	if err != nil {
		return nil, fmt.Errorf("could not get state parameter from session store: %w", err)
	}

	redirectURL := ""
	err = oauthFlowSession.Get(oauthFlowRedirectKey, &redirectURL)
	if err != nil {
		return nil, fmt.Errorf("redirect key %v does not exist in oauthFlowSession.Values", oauthFlowRedirectKey)
	}

	ctx := context.Background()
	code := h.FormValue("code")
	tok, err := ua.cfg.Exchange(ctx, code)
	if err != nil {
		return nil, fmt.Errorf("exchange failed with error: %w", err)
	}

	sess, err := h.LoadSession(ua.SessionID)
	if err != nil {
		return nil, fmt.Errorf("could not create session %s: %w", ua.SessionID, err)
	}
	err = sess.SetMaxAge(ua.MaxAge)
	if err != nil {
		return nil, fmt.Errorf("unable to set session MaxAge: %w", err)
	}

	clt := oauth2.NewClient(ctx, ua.cfg.TokenSource(ctx, tok))
	profile, err := fetchProfile(clt)
	if err != nil {
		return nil, fmt.Errorf("could not fetch profile: %w", err)
	}

	err = sess.Set(oauthTokenSessionKey, tok)
	if err != nil {
		return nil, fmt.Errorf("unable to set token session key: %w", err)
	}
	err = sess.Set(profileKey, profile)
	if err != nil {
		return nil, fmt.Errorf("unable to set profile key: %w", err)
	}
	err = h.SaveSession(sess)
	if err != nil {
		return nil, fmt.Errorf("could not save session %s: %w", ua.SessionID, err)
	}

	return profile, h.Redirect(redirectURL, http.StatusFound)
}

func (ua *UserAuth) GoogleLoginHandler(h backend.Handler) (*Profile, error) {

	cookieToken := h.Cookie("g_csrf_token")
	requestToken := h.FormValue("g_csrf_token")

	if cookieToken != requestToken {
		return nil, errors.New("mismatch in cookie, and body tokens")
	}

	idToken := h.FormValue("credential")

	// Verify token.
	ctx := context.Background()
	validator, err := idtoken.NewValidator(ctx)
	if err != nil {
		return nil, fmt.Errorf("unable to get new idtoken validator: %w", err)
	}

	payload, err := validator.Validate(ctx, idToken, "")
	if err != nil {
		return nil, fmt.Errorf("unable to validate id token: %v", err)
	}

	sess, err := h.LoadSession(ua.SessionID)
	if err != nil {
		return nil, fmt.Errorf("could not create session %s: %w", ua.SessionID, err)
	}
	err = sess.SetMaxAge(ua.MaxAge)
	if err != nil {
		return nil, fmt.Errorf("unable to set session MaxAge: %w", err)
	}

	p := &Profile{}
	var ok bool
	if p.GivenName, ok = payload.Claims["given_name"].(string); !ok {
		return nil, errors.New("cannot assert given name to string")
	}
	if p.FamilyName, ok = payload.Claims["family_name"].(string); !ok {
		return nil, errors.New("cannot assert family name to string")
	}
	if p.Email, ok = payload.Claims["email"].(string); !ok {
		return nil, errors.New("cannot assert email to string")
	}

	err = sess.Set(idTokenSessionKey, struct{ IDToken string }{IDToken: idToken})
	if err != nil {
		return nil, fmt.Errorf("unable to set token session key: %w", err)
	}
	err = sess.Set(profileKey, p)
	if err != nil {
		return nil, fmt.Errorf("unable to set profile key: %w", err)
	}
	err = h.SaveSession(sess)
	if err != nil {
		return nil, fmt.Errorf("could not save session %s: %w", ua.SessionID, err)
	}

	return p, nil
}

// fetchProfile retrieves profile info for the logged-in user, i.e.,
// the user associated with the client's OAuth token, via the Google
// People API, which must be enabled for the App Engine project.
// See https://developers.google.com/people/v1/read-people.
func fetchProfile(clt *http.Client) (*Profile, error) {
	peopleService, err := people.New(clt)
	if err != nil {
		return nil, err
	}
	person, err := peopleService.People.Get("people/me").PersonFields("names,emailAddresses,locales").Do()
	if err != nil {
		return nil, fmt.Errorf("People.Get failed: %w", err)
	}

	var profile Profile
	if len(person.Names) != 0 {
		profile.GivenName = person.Names[0].GivenName
		profile.FamilyName = person.Names[0].FamilyName
	}
	if len(person.EmailAddresses) != 0 {
		profile.Email = person.EmailAddresses[0].Value
	}
	if len(person.Locales) != 0 {
		profile.Locale = person.Locales[0].Value
	}

	return &profile, nil
}

// LogoutHandler logs out the current user by clearing the default session.
func (ua *UserAuth) LogoutHandler(h backend.Handler) error {
	ua.Lock()
	defer ua.Unlock()

	if ua.cfg == nil {
		return NotConfigured
	}

	sess, err := h.LoadSession(ua.SessionID)
	if err != nil {
		return fmt.Errorf("could not create session %s: %w", ua.SessionID, err)
	}
	err = sess.Invalidate() // Clear session.
	if err != nil {
		return fmt.Errorf("unable to invalidate session: %w", err)
	}
	err = h.SaveSession(sess)
	if err != nil {
		return fmt.Errorf("could not save session %s: %w", ua.SessionID, err)
	}

	redirectURL := h.FormValue("redirect")
	if redirectURL == "" {
		redirectURL = "/"
	}
	return h.Redirect(redirectURL, http.StatusFound)
}

// GetProfile retrieves the profile for a logged in user, or nil otherwise.
// If the OAuth session is still valid, the profile is retrieved from the session store.
// If not, a new client request is issued to obtain the profile anew.
// Optional profile data is preserved.
func (ua *UserAuth) GetProfile(h backend.Handler) (*Profile, error) {
	ua.Lock()
	defer ua.Unlock()

	if ua.cfg == nil {
		return nil, NotConfigured
	}

	sess, err := h.LoadSession(ua.SessionID)
	if err != nil {
		return nil, SessionNotFound
	}

	tok := &oauth2.Token{}
	idTok := &struct{ IDToken string }{}
	err = sess.Get(oauthTokenSessionKey, &tok)
	if err != nil {
		// Try id token instead.
		err = sess.Get(idTokenSessionKey, &idTok)
		if err != nil {
			return nil, TokenNotFound
		}
	}

	profile := &Profile{}
	err = sess.Get(profileKey, &profile)
	if err != nil {
		return nil, ProfileNotFound
	}
	ctx := h.Context()

	// Using Oauth2 Tokens.
	if *tok != (oauth2.Token{}) {
		if tok.Valid() {
			return profile, nil
		}

		// Issue a new client request to refresh the OAuth token.
		src := ua.cfg.TokenSource(ctx, tok)
		newTok, err := src.Token()
		if err != nil {
			return nil, fmt.Errorf("could not get refreshed token: %w", err)
		}
		clt := ua.cfg.Client(ctx, newTok)
		data := profile.Data // Save optional data.
		profile, err = fetchProfile(clt)
		if err != nil {
			return nil, fmt.Errorf("fetch profile error: %w", err)
		}

		profile.Data = data // Restore optional data.
		err = sess.Set(oauthTokenSessionKey, newTok)
		if err != nil {
			return nil, fmt.Errorf("unable to set token session key: %w", err)
		}
	} else {
		validator, err := idtoken.NewValidator(ctx)
		if err != nil {
			return nil, fmt.Errorf("unable to get new validator: %w", err)
		}

		_, err = validator.Validate(ctx, idTok.IDToken, "")
		if err != nil {
			return nil, fmt.Errorf("unable to validate idtoken: %w", err)
		}

		err = sess.Set(idTokenSessionKey, idTok)
		if err != nil {
			return nil, fmt.Errorf("unable to set token session key: %w", err)
		}
	}

	err = sess.Set(profileKey, profile)
	if err != nil {
		return nil, fmt.Errorf("unable to set profile key: %w", err)
	}

	err = h.SaveSession(sess)
	if err != nil {
		return nil, fmt.Errorf("session save error: %w", err)
	}

	return profile, nil
}

// PutData updates optional data for the logged-in user.
func (ua *UserAuth) PutData(h backend.Handler, data string) error {
	ua.Lock()
	defer ua.Unlock()

	if ua.cfg == nil {
		return NotConfigured
	}
	sess, err := h.LoadSession(ua.SessionID)
	if err != nil {
		return SessionNotFound
	}
	tok := &oauth2.Token{}
	err = sess.Get(oauthTokenSessionKey, &tok)
	if err != nil {
		return TokenNotFound
	}
	if !tok.Valid() {
		return fmt.Errorf("token invalid, token: %+v", tok)
	}
	profile := &Profile{}
	err = sess.Get(profileKey, &profile)
	if err != nil {
		return ProfileNotFound
	}
	profile.Data = data
	err = sess.Set(profileKey, profile)
	if err != nil {
		return fmt.Errorf("unable to set profile key: %w", err)
	}
	return h.SaveSession(sess)
}
