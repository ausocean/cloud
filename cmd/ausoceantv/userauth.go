/*
DESCRIPTION
  Google authentication ("gauth") services using OAuth2.

AUTHORS
  David Sutton <davidsutton@ausocean.org>

LICENSE
  Copyright (C) 2024 the Australian Ocean Lab (AusOcean)

  This is free software: you can redistribute it and/or modify it
  under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  It is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  in gpl.txt. If not, see http://www.gnu.org/licenses/.
*/

package main

import (
	"context"
	"encoding/gob"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"os"
	"sync"
	"time"

	"github.com/ausocean/cloud/gauth"

	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/log"
	"github.com/gofiber/fiber/v2/middleware/session"
	"golang.org/x/oauth2"
	"golang.org/x/oauth2/google"
	"google.golang.org/api/people/v1"
)

const (
	// Keys used for default OAuth session.
	oauthTokenSessionKey = "oauth_token"
	profileKey           = "google_profile"

	// Key used in the OAuth flow session to store the URL to
	// redirect the user to after the OAuth flow is complete.
	oauthFlowRedirectKey = "redirect"

	// Default timeout (1 day).
	defaultOauthMaxAge = 60 * 60 * 24

	// Default OAuth redirect URL.
	oauthRedirectUTL = "http://localhost:8084/oauth2callback"
)

// Profile holds info about the logged-in user.
// GivenName, FamilyName, Email, and Locale come from the Google user profile.
// Data is optional non-persistent data associated with the user.
type Profile struct {
	GivenName  string
	FamilyName string
	Email      string
	Locale     string
	Data       string
}

// UserAuth implements authentication of Google users using OAuth2.
// User authentication involves two steps:
//
//	Redirecting the user to Google's authorization service.
//	Processing the response when Google redirects the user back to us.
//
// See also:
//
//	https://godoc.org/google.golang.org/api/people/v1
//	https://developers.google.com/people/v1/how-tos/authorizing
type UserAuth struct {
	sync.Mutex
	ProjectID    string         // GAE project ID.
	ClientID     string         // Oauth2 client ID.
	SessionID    string         // Default OAuth2 session ID.
	MaxAge       int            // OAuth2 max age in seconds.
	cfg          *oauth2.Config // OAuth2 configuration.
	sessionStore *session.Store // Store for sessions.
}

var (
	NotConfigured   = errors.New("oauth2 not configured")
	SessionNotFound = errors.New("oauth2 session not found")
	TokenNotFound   = errors.New("oauth2 token not found")
	TokenInvalid    = errors.New("oauth2 token invalid")
	ProfileNotFound = errors.New("profile not found")
)

// Init initializes Google user authentication using OAuth2.
// It requires the use of two secrets obtained via GetSecrets:
//
//	clientSecret: the OAuth 2 client secret for the given client ID.
//	sessionKey:   the secure cookie generated by securecookie.GenerateRandomKey(32).
func (ua *UserAuth) Init() {
	ua.Lock()
	defer ua.Unlock()

	if ua.cfg != nil {
		return // Already initialized!
	}

	// Register gobs for the OAuth2 token and user profile.
	gob.Register(&oauth2.Token{})
	gob.Register(&Profile{})

	// Get our client secrets.
	ctx := context.Background()
	secrets, err := gauth.GetSecrets(ctx, ua.ProjectID, []string{"clientSecret", "sessionKey"})
	if err != nil {
		log.Errorf("GetSecrets failed with error: %v", err)
		return
	}

	// Session ID is the name the default OAuth2 session.
	if ua.SessionID == "" {
		ua.SessionID = ua.ProjectID + "Auth"
	}
	if ua.MaxAge == 0 {
		ua.MaxAge = oauthMaxAge
	}

	// Configure our OAuth URL.
	ua.cfg = configureOAuthClient(ua.ClientID, secrets["clientSecret"])
}

// configureOAuthClient configures the URL that is sent to
// Google's authorization service, requesting the use of the "email"
// and "profile" OAuth scopes.
func configureOAuthClient(clientID, clientSecret string) *oauth2.Config {
	redirectURL := os.Getenv("OAUTH2_CALLBACK")
	if redirectURL == "" {
		log.Info("OAUTH2_CALLBACK not defined; defaulting to " + oauthRedirectUTL)
		redirectURL = oauthRedirectUTL
	}
	return &oauth2.Config{
		ClientID:     clientID,
		ClientSecret: clientSecret,
		RedirectURL:  redirectURL,
		Scopes:       []string{"email", "profile"},
		Endpoint:     google.Endpoint,
	}
}

// LoginHandler initiates an OAuth flow to authenticate the user,
// storing the state in a session of age oauthMaxAge. The session ID,
// which is a UUID, is used as the OAuth state parameter.
// See also https://godoc.org/golang.org/x/oauth2#Config.AuthCodeURL.
func (svc *service) LoginHandler(ctx *fiber.Ctx) error {
	svc.auth.Lock()
	defer svc.auth.Unlock()

	if svc.auth.cfg == nil {
		return NotConfigured
	}

	sess, err := svc.auth.sessionStore.Get(ctx)
	if err != nil {
		log.Errorf("could not get session: %v", err)
	}

	sessID := sess.ID()

	sess.SetExpiry(time.Second * time.Duration(svc.auth.MaxAge))

	redirectURL, err := validateRedirectURL(ctx.FormValue("redirect"))
	if err != nil {
		return fmt.Errorf("invalid redirect URL: %w", err)
	}
	sess.Set(oauthFlowRedirectKey, redirectURL)

	err = sess.Save()
	if err != nil {
		log.Errorf("could not save session: %v", err)
	}

	ctx.WriteString(sessID)

	// NB: Offline access is required to obtain a refresh token.
	url := svc.auth.cfg.AuthCodeURL(sessID, oauth2.ApprovalForce, oauth2.AccessTypeOffline)
	ctx.Redirect(url, http.StatusFound)
	return nil
}

// validateRedirectURL checks that the URL provided is valid, i.e.,
// relative to this server. If the URL is missing, redirect the user
// to our home page.
func validateRedirectURL(path string) (string, error) {
	if path == "" {
		return "/", nil
	}

	url, err := url.Parse(path)
	if err != nil {
		return "/", err
	}
	if url.IsAbs() {
		return "/", errors.New("URL must not be absolute")
	}
	return path, nil
}

// CallbackHandler completes the OAuth flow, retrieves the user's
// profile information and stores info in the default session.
func (svc *service) CallbackHandler(c *fiber.Ctx) error {
	svc.auth.Lock()
	defer svc.auth.Unlock()

	if svc.auth.cfg == nil {
		return NotConfigured
	}

	oauthFlowSession, err := svc.auth.sessionStore.Get(c)
	if err != nil {
		return fmt.Errorf("could not get current session: %w", err)
	}

	if c.FormValue("state") != oauthFlowSession.ID() {
		return fmt.Errorf("mismatch in state and current session ID")
	}

	redirectURL := oauthFlowSession.Get(oauthFlowRedirectKey).(string)

	ctx := context.Background()
	code := c.FormValue("code")
	tok, err := svc.auth.cfg.Exchange(ctx, code)
	if err != nil {
		return fmt.Errorf("exchange failed with error: %w", err)
	}

	sess, err := svc.auth.sessionStore.Get(c)
	if err != nil {
		return fmt.Errorf("could not create session: %w", err)
	}

	clt := oauth2.NewClient(ctx, svc.auth.cfg.TokenSource(ctx, tok))
	profile, err := fetchProfile(clt)
	if err != nil {
		return fmt.Errorf("could not fetch profile: %w", err)
	}

	sess.Set(oauthTokenSessionKey, tok)
	sess.Set(profileKey, profile)
	err = sess.Save()
	if err != nil {
		return fmt.Errorf("could not save session: %w", err)
	}

	c.Redirect(redirectURL, http.StatusFound)
	return nil
}

// fetchProfile retrieves profile info for the logged-in user, i.e.,
// the user associated with the client's OAuth token, via the Google
// People API, which must be enabled for the App Engine project.
// See https://developers.google.com/people/v1/read-people.
func fetchProfile(clt *http.Client) (*Profile, error) {
	peopleService, err := people.New(clt)
	if err != nil {
		return nil, err
	}
	person, err := peopleService.People.Get("people/me").PersonFields("names,emailAddresses,locales").Do()
	if err != nil {
		return nil, fmt.Errorf("People.Get failed: %w", err)
	}

	var profile Profile
	if len(person.Names) != 0 {
		profile.GivenName = person.Names[0].GivenName
		profile.FamilyName = person.Names[0].FamilyName
	}
	if len(person.EmailAddresses) != 0 {
		profile.Email = person.EmailAddresses[0].Value
	}
	if len(person.Locales) != 0 {
		profile.Locale = person.Locales[0].Value
	}

	return &profile, nil
}

// LogoutHandler logs out the current user by clearing the default session.
func (svc *service) LogoutHandler(c *fiber.Ctx) error {
	svc.auth.Lock()
	defer svc.auth.Unlock()

	if svc.auth.cfg == nil {
		return NotConfigured
	}

	sess, err := svc.auth.sessionStore.Get(c)
	if err != nil {
		return fmt.Errorf("could not create session: %w", err)
	}
	err = sess.Destroy()
	if err != nil {
		return fmt.Errorf("could not destroy session: %w", err)
	}
	err = sess.Save()
	if err != nil {
		return fmt.Errorf("could not save session: %w", err)
	}

	redirectURL := c.FormValue("redirect")
	if redirectURL == "" {
		redirectURL = "/"
	}
	c.Redirect(redirectURL, http.StatusFound)
	return nil
}

// GetProfile retrieves the profile for a logged in user, or nil otherwise.
// If the OAuth session is still valid, the profile is retrieved from the session store.
// If not, a new client request is issued to obtain the profile anew.
// Optional profile data is preserved.
func (svc *service) GetProfile(c *fiber.Ctx) (*Profile, error) {
	svc.auth.Lock()
	defer svc.auth.Unlock()

	if svc.auth.cfg == nil {
		return nil, NotConfigured
	}

	sess, err := svc.auth.sessionStore.Get(c)
	if err != nil {
		return nil, SessionNotFound
	}

	tokenValue := sess.Get(oauthTokenSessionKey)
	if tokenValue == nil {
		return nil, TokenNotFound
	}

	tok, ok := tokenValue.(*oauth2.Token)
	if !ok {
		return nil, fmt.Errorf("could not assert session token as type *oauth2.Token")
	}

	profile := sess.Get(profileKey).(*Profile)

	if tok.Valid() {
		return profile, nil
	}

	// Issue a new client request to refresh the OAuth token.
	ctx := c.Context()
	src := svc.auth.cfg.TokenSource(ctx, tok)
	newTok, err := src.Token()
	if err != nil {
		return nil, fmt.Errorf("could not get refreshed token: %w", err)
	}
	clt := svc.auth.cfg.Client(ctx, newTok)
	data := profile.Data // Save optional data.
	profile, err = fetchProfile(clt)
	if err != nil {
		return nil, fmt.Errorf("fetch profile error: %w", err)
	}

	profile.Data = data // Restore optional data.
	sess.Set(oauthTokenSessionKey, newTok)
	sess.Set(profileKey, profile)

	err = sess.Save()
	if err != nil {
		return nil, fmt.Errorf("session save error: %w", err)
	}

	return profile, nil
}
